import pandas as pd
from sqlalchemy import create_engine
import schedule
import time

# === 1. MySQL Configuration ===
user = 'root'
password = '1234'
host = 'localhost'
port = '3306'

raw_db = 'jnjrawdata'
clean_db = 'jnjcleandata'

raw_engine = create_engine(f"mysql+pymysql://{user}:{password}@{host}:{port}/{raw_db}")
clean_engine = create_engine(f"mysql+pymysql://{user}:{password}@{host}:{port}/{clean_db}")

def clean_dataframe(df):
    df = df.applymap(lambda x: x.strip() if isinstance(x, str) else x)
    df.replace('', pd.NA, inplace=True)
    df.dropna(inplace=True)
    return df

def create_empty_tables(clean_table, agg_table, raw_table):
    # Define empty DataFrames with expected columns per table (all lowercase)
    if raw_table == 'supplier_information_raw':
        empty_clean_df = pd.DataFrame(columns=['supplierid', 'suppliername', 'country', 'othercolumns...'])  # adjust columns as needed
        empty_agg_df = pd.DataFrame(columns=['country', 'suppliercount'])
    elif raw_table == 'supplier_performance_raw':
        empty_clean_df = pd.DataFrame(columns=['performanceid', 'supplierid', 'qualityscore', 'othercolumns...'])
        empty_agg_df = pd.DataFrame(columns=['supplierid', 'avgqualityscore'])
    elif raw_table == 'sourcing_contracts_raw':
        empty_clean_df = pd.DataFrame(columns=['contractid', 'supplierid', 'contractvalue', 'othercolumns...'])
        empty_agg_df = pd.DataFrame(columns=['supplierid', 'totalcontractvalue'])
    elif raw_table == 'purchase_orders_raw':
        empty_clean_df = pd.DataFrame(columns=['po_id', 'currency', 'total_amount', 'othercolumns...'])
        empty_agg_df = pd.DataFrame(columns=['currency', 'totalspend'])
    elif raw_table == 'purchase_order_details_raw':
        empty_clean_df = pd.DataFrame(columns=['podetailid', 'itemid', 'quantity', 'othercolumns...'])
        empty_agg_df = pd.DataFrame(columns=['itemid', 'totalquantity'])
    elif raw_table == 'spend_analysis_raw':
        empty_clean_df = pd.DataFrame(columns=['spendid', 'category', 'amount_spend', 'othercolumns...'])
        empty_agg_df = pd.DataFrame(columns=['category', 'totalspend'])
    else:
        empty_clean_df = pd.DataFrame()
        empty_agg_df = pd.DataFrame()

    empty_clean_df.to_sql(clean_table, clean_engine, if_exists='replace', index=False)
    empty_agg_df.to_sql(agg_table, clean_engine, if_exists='replace', index=False)
    print(f"‚ö†Ô∏è Created empty `{clean_table}` and `{agg_table}` tables because raw table `{raw_table}` does not exist.")

def etl_clean_and_sync():
    print("\nüîÑ Starting ETL clean and sync of all raw tables...")

    table_configs = {
        'supplier_information_raw': ('supplierid', 'supplier_information', 'agg_suppliercountbycountry'),
        'supplier_performance_raw': ('performanceid', 'supplier_performance', 'agg_avgqualityscorebysupplier'),
        'sourcing_contracts_raw': ('contractid', 'sourcing_contracts', 'agg_totalcontractvaluebysupplier'),
        'purchase_orders_raw': ('po_id', 'purchase_orders', 'agg_totalspendbycurrency'),
        'purchase_order_details_raw': ('podetailid', 'purchase_order_details', 'agg_totalquantitybyitem'),
        'spend_analysis_raw': ('spendid', 'spend_analysis', 'agg_totalspendbycategory')
    }

    for raw_table, (id_col, clean_table, agg_table) in table_configs.items():
        try:
            print(f"\nüì• Processing `{raw_table}`...")
            df = pd.read_sql(f"SELECT * FROM {raw_table}", raw_engine)
            df = clean_dataframe(df)

            if df.empty:
                print(f"‚ö†Ô∏è Raw table `{raw_table}` is empty. Creating empty clean and aggregate tables.")
                create_empty_tables(clean_table, agg_table, raw_table)
                continue

            # Table-specific cleaning & aggregation
            if raw_table == 'supplier_information_raw':
                df['country'] = df['country'].str.title()
                agg = df.groupby('country')['supplierid'].nunique().reset_index(name='suppliercount')

            elif raw_table == 'supplier_performance_raw':
                df['qualityscore'] = pd.to_numeric(df['qualityscore'], errors='coerce')
                agg = df.groupby('supplierid')['qualityscore'].mean().reset_index(name='avgqualityscore')

            elif raw_table == 'sourcing_contracts_raw':
                df['contractvalue'] = pd.to_numeric(df['contractvalue'], errors='coerce')
                agg = df.groupby('supplierid')['contractvalue'].sum().reset_index(name='totalcontractvalue')

            elif raw_table == 'purchase_orders_raw':
                df['currency'] = df['currency'].str.upper()
                df['total_amount'] = pd.to_numeric(df['total_amount'], errors='coerce')
                agg = df.groupby('currency')['total_amount'].sum().reset_index(name='totalspend')

            elif raw_table == 'purchase_order_details_raw':
                df['quantity'] = pd.to_numeric(df['quantity'], errors='coerce')
                agg = df.groupby('itemid')['quantity'].sum().reset_index(name='totalquantity')

            elif raw_table == 'spend_analysis_raw':
                df['category'] = df['category'].str.title()
                df['amount_spend'] = pd.to_numeric(df['amount_spend'], errors='coerce')
                agg = df.groupby('category')['amount_spend'].sum().reset_index(name='totalspend')

            else:
                agg = pd.DataFrame()

            # Write cleaned and aggregated data to clean DB
            df.to_sql(clean_table, clean_engine, if_exists='replace', index=False)
            print(f"‚úÖ Cleaned data written to `{clean_table}` ({len(df)} rows)")

            agg.to_sql(agg_table, clean_engine, if_exists='replace', index=False)
            print(f"üìä Aggregated data written to `{agg_table}`")

        except Exception as e:
            if "doesn't exist" in str(e).lower():
                print(f"‚ùå Raw table `{raw_table}` does not exist.")
                create_empty_tables(clean_table, agg_table, raw_table)
            else:
                print(f"‚ùå Error processing `{raw_table}`: {e}")
                try:
                    with clean_engine.connect() as conn:
                        conn.execute(f"DROP TABLE IF EXISTS {clean_table}")
                        conn.execute(f"DROP TABLE IF EXISTS {agg_table}")
                    print(f"‚ö†Ô∏è Dropped `{clean_table}` and `{agg_table}` due to error.")
                except Exception as drop_err:
                    print(f"‚ùå Failed to drop clean tables `{clean_table}` or `{agg_table}`: {drop_err}")

    print("\n‚úÖ ETL completed for all tables.")

# Schedule ETL every 5 minutes (adjust as needed)
schedule.every(5).minutes.do(etl_clean_and_sync)

# Run once immediately on startup
etl_clean_and_sync()

print("üîÅ ETL is running. It will repeat every 5 minutes. (Press Ctrl+C to stop)")
while True:
    schedule.run_pending()
    time.sleep(1)
